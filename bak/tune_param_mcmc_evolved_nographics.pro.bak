; 1. Read a .MCMC file as generated by mcmc_window_gen (with missing lines at the bottom)
; 2. Show The initial fit as configured in the .MCMC
; 3. Let the user interactively set 
;		- The widths (scaled using the sun width profile)
;		- The Height (scaled using a gaussian)
;		- The splitting a1
;		- The stellar inclination i
; 4. Save the new configuration in .MCMC and .model format for the fit of a1, eta, a3, asym
@build_init_param_a1a2a3_evolved.pro
@global_fit_a1a2a3.pro
;@star_mode_ID.pro
pro tune_param_mcmc_evolved_nographics, kic_n, data_type
!p.multi=0

	; ----- ADAPT IN FUNCTION OF YOUR LOCAL DIRECTORY -------
	;dir_mcmc='/home/obenomar/Pro/PSM_WP128_Sept2018/Data/TAMCMC-setups/'
	;dir_spec='/home/obenomar/Pro/PSM_WP128_Sept2018/Data/sav/'
	dir_mcmc='/Volumes/MCMC_RES/Temporary-Outputs/RGB-depressed/Level1/setups/l023-only/'
	dir_spec='/Volumes/MCMC_RES/Temporary-Outputs/RGB-depressed/Level0/tf_mosser2017/'
	sav2data=1 ; If set to 1, then convert the sav file into a .data file (keeping f=[fmin,fmax] only)
	; --------------------------------------------------------


	if Data_type eq 'EPIC' then begin
		dir_spec=dir_spec + 'EPIC/'
		dir_mcmc=dir_mcmc + 'EPIC/'
	endif
	if Data_type eq 'KOI_Campante2016' then begin
		dir_spec=dir_spec + 'KOI_Campante2016/'
		dir_mcmc=dir_mcmc + 'KOI_Campante2016/'
	endif

	if Data_type eq 'KOI_Campante2016_wpsd' then begin
		dir_spec=dir_spec + 'KOI_Campante2016_wpsd_Tiago/'
		dir_mcmc=dir_mcmc + 'KOI_Campante2016_wpsd_Tiago/'
	endif

	if Data_type eq 'Difrot' OR Data_type eq 'difrot' then begin
		dir_spec=dir_spec + 'Dif-Rot-2017/'
		dir_mcmc=dir_mcmc + 'Dif-Rot-2017/'
	endif
	if Data_type eq 'Difrot-kasoc' OR Data_type eq 'difrot-kasoc' then begin
		dir_spec=dir_spec + 'Dif-Rot-2017-kasoc/'
		dir_mcmc=dir_mcmc + 'Dif-Rot-2017-kasoc/'
	endif

	; ------ Configuration for the global priors and inputs -----
	; Here are defined the names of the global parameters along with their default priors
	; Completition of the values FOR a1 and inclination IS MADE AT THE END OF THIS FUNCTION
	global_params_names=['model_fullname','freq_smoothness', 'Splitting_a1',  'Asphericity_eta', $
						 'Splitting_a3', 'Asymetry', 'Inclination', $
						 'Visibility_l1', 'Visibility_l2', 'Visibility_l3']	
	global_priors_names=['model_Evolved_Global_a1etaa3_l1mixed', 'bool', 'Uniform', 'Fix_Auto', $
					     'Fix', 'Fix', 'Uniform_cos', $
					     'Gaussian', 'Gaussian', 'Gaussian']
	global_priors_params=dblarr(n_elements(global_priors_names), 5)
	global_priors_params[*,*]=-9999
	
	global_priors_params[where(global_params_names eq 'freq_smoothness'), 0]=1 ; Activate/Deactivate the smoothness condition on frequencies SMOOTHNESS APPLIED ONLY FOR l=0,2,3
	global_priors_params[where(global_params_names eq 'freq_smoothness'), 1]=2.0 ; Smoothness coeficient
	
	; Splitting Fixed to 0. by default
	global_priors_params[where(global_params_names eq 'Splitting_a3'), 0]=0.
	; Asphericity Fixed to the centrifugal effect by default
	global_priors_params[where(global_params_names eq 'Asphericity_eta'), 0]=1
	; Asymetry Fixed to 0 by default
	global_priors_params[where(global_params_names eq 'Asymetry'), 0]=0.
	; Visibilities Gaussian and around Solar values by default
	global_priors_params[where(global_params_names eq 'Visibility_l1'), 0:2]=[1.5, 1.5, 0.15]
	global_priors_params[where(global_params_names eq 'Visibility_l2'), 0:2]=[0.53, 0.53, 0.05]
	global_priors_params[where(global_params_names eq 'Visibility_l3'), 0:2]=[0.08, 0.08, 0.02]
	; -------------------------------------------------------
	
	; Restore the power spectrum
	security=0 & Kic_number=kic_n
	while n_elements(byte(kic_number)) lt 9 AND security lt 10 do begin
		KIC_number='0'+KIC_number
		security=security+1
	endwhile

	exist=file_search(dir_spec+KIC_number+'.sav')
	exist2=file_search(dir_spec+'*' + KIC_n+'*.sav')
	if exist ne '' then restore, dir_spec+KIC_number+'.sav'
	if exist eq '' AND exist2 ne '' then begin
		exist=exist2
		if n_elements(exist2) eq 1 then begin
			restore, exist2[0]
		endif else begin
			print, 'Multiple spectrum files that match the kic_n were found. Please choose one among the list of possible:'
			for i=0, n_elements(exist2)-1 do begin
				print, ' [' + strtrim(i,2) + '] ' + exist2[i]
			endfor
			read, a, format='(i)', prompt='Enter the index of the file: '
			restore, exist2[a]
			exist=exist2[a]
		endelse
	endif
	if exist eq '' AND exist2 eq '' then begin
		print, ' No file found matching any known syntax!'
		stop
	endif
	spec=spec_reg

	; Reading the .MCMC file and format it so that it can be read by global_fit_a1a2a3.pro
	file_out_res=file_search(dir_mcmc + '*' + kic_n +'.MCMC')
	if n_elements(file_out_res) eq 1 then begin
		struc=build_init_param_a1a2a3_evolved(file_out_res)
	endif else begin
		print, 'Multiple mcmc files that match the kic_n were found. Please choose one among the list of possible:'
		for i=0, n_elements(file_out_res)-1 do begin
			print, ' [' + strtrim(i,2) + '] ' + exist2[i]
		endfor
		read, a, format='(i)', prompt='Enter the index of the file: '
		struc=build_init_param_a1a2a3_evolved(file_out_res[a])
	endelse	
	; define initial values for the different variables	
	parameters_length=struc.parameters_length
	params=struc.input
	fmin=struc.fmin
	fmax=struc.fmax
	
	Nmax=parameters_length[0]
	lmax=parameters_length[1]

	; tweaking the smoothing coeficient
	resol=freq[1] - freq[0]
	gamma0=mean(params[total(parameters_length[0:3]): total(parameters_length[0:4])-1])/2.
	scoef=gamma0/resol

	; calculating the initial range of frequencies and the smooth spectra
	xpos=where(freq ge fmin AND freq le fmax)
	x=freq[xpos]
	y_smooth=smooth(spec_reg, scoef, /edge_truncate)
	y_smooth2=smooth(spec_reg, scoef/2, /edge_truncate)
	y_smooth=y_smooth[xpos]
	y_smooth2=y_smooth2[xpos]
	
	; calculating the width profile, scaled with the Sun
	nu=dblarr(lmax+1, Nmax)
	pos0=total(parameters_length[0:1]) + 2 
	for en=0, Nmax-1 do begin	
		for el=0, lmax do begin
			nu[el,en]=params[pos0 + en*(lmax+1) + el]
		endfor
	endfor
	
	; Large separation as defined by the frequency list
	fit=linfit(findgen(Nmax), nu[0,*])
	Dnu=fit[1]

	; defining numax by using the table of frequency and of heights
	numax=total(params[0:Nmax-1]*nu[0,*])/total(params[0:Nmax-1]) ; weighted mean
	; defining Hmax by interpolation of the Heights at numax
	Hmax=interpol(params[0:Nmax-1], nu[0,*], numax)
	Hsigma=3*Dnu
	; Deducing the Heights for l=0 modes
	H0=Hmax * exp(- 0.5*(nu[0,*] - numax)^2./Hsigma^2)
	params[0:Nmax-1]=H0

	Widths=tweak_width_profile(nu, numax, gamma0)

	params[total(parameters_length[0:3]): total(parameters_length[0:4])-1]=widths[0,*]	

	; Calculating the model using all the calculations from earlier
	;model0=global_fit_a1a2a3(params,parameters_length, x)

	ymax=max(y_smooth)
	plot, x, y_smooth, color=fsc_color('Black'), background=fsc_color('white'), $
		xr=[min(x), max(x)], /xst, yr=[0, ymax], /yst
	;oplot, x, model0, color=fsc_color('blue')

	; ------- Definition of the increments and of inutial values ---------
	inc=params[total(parameters_length[0:5])]
	inc_old=inc
	a1=0.4 ; Solar value by default params[total(parameters_length[0:2])]
	a1_old=a1
	Hmax_old=Hmax
	Hsigma_old=Hsigma
	gamma0_old=gamma0
	
	dinc=10;
	dwidth=0.1*gamma0
	dHmax=0.1*Hmax
	dHsigma=0.1*Hsigma
	da1=0.1
	; ----------------------------------------------


; ---- Parameters of the graphical interface ----
c_max=2
ps=0
overplot=2 ; show diamonds only
color=['Orange', 'Red','Dark Gray', 'Brown']
win_factor=0.8 ; use this to rescale windows when they are too big/small relative to the used screen resolution

; -----------------------------------------------

; -------------- Compatibility setup --------------
f_list=0 & tag_id_list=0
for el=0, lmax do begin
	test=where(nu[el,*] ne 0)
	if test[0] ne -1 then begin
		tag_id_list=[ tag_id_list, dblarr(n_elements(test))+el ]
	 	f_list=[f_list, reform(nu[el,test])]
	endif
endfor
; -------------------------------------------------

;stop
coef=1.
key='n' & status=0

	
	; -------------
	; Update the global priors with tweaked values
	; -------------
	; Splitting a1:
	if a1 le 0.5 then a1max=1.5
	if a1 gt 0.5 and a1 le 1.0 then a1max=2.5
	if a1 gt 1.0 then a1max=5.
	global_priors_params[where(global_params_names eq 'Splitting_a1'), 0:2]=[a1, 0, a1max]
	
	; Inclination:
	global_priors_params[where(global_params_names eq 'Inclination'), 0:2]=[inc, 0., 1]

	; --- Formating output so that they can be written in a model file -----
	guesses=Read_MCMC_input(file_out_res, Dnu=Dnu, C_l=C_l, mode_range=mode_range)
	posl0=where(guesses.eigen_param[0,*] eq 0)
	posl1=where(guesses.eigen_param[0,*] eq 1)
	posl2=where(guesses.eigen_param[0,*] eq 2)
	posl3=where(guesses.eigen_param[0,*] eq 3)
	
	els=dblarr(n_elements(posl0))
	freq_l=reform(guesses.eigen_param[1,posl0])
	fl0_win=guesses.eigen_param[2:3,posl0]
	Width_l0=tweak_width_profile_l(reform(guesses.eigen_param[1,posl0]), reform(guesses.eigen_param[1,posl0]), 0, numax, gamma0)
	Amp_l0=H0
	if lmax ge 1 then begin
		els=[els, dblarr(n_elements(posl1)) + 1]
		freq_l=[freq_l, reform(guesses.eigen_param[1,posl1])]
		fl1_win=guesses.eigen_param[2:3,posl1]	
		Width_l1=tweak_width_profile_l(reform(guesses.eigen_param[1,posl1]), reform(guesses.eigen_param[1,posl0]), 1, numax, gamma0)
		;Width_l1=widths[1,*]
		Amp_l1=interpol(H0, reform(guesses.eigen_param[1,posl0]), reform(guesses.eigen_param[1,posl1]));H0*params[parameters_length[0]]
		Amp_l1=abs(Amp_l1*1.5)
	endif
	if lmax ge 2 then begin	
		els=[els, dblarr(n_elements(posl2)) + 2]
		freq_l=[freq_l, reform(guesses.eigen_param[1,posl2])]
		fl2_win=guesses.eigen_param[2:3,posl2]
		Width_l2=tweak_width_profile_l(reform(guesses.eigen_param[1,posl2]),reform(guesses.eigen_param[1,posl0]), 2, numax, gamma0) 
		;Width_l2=widths[2,*]	
		Amp_l2=H0*params[parameters_length[0]+1]
	endif
	if lmax ge 3 then begin
		els=[els, dblarr(n_elements(posl3)) + 3]
		freq_l=[freq_l, reform(guesses.eigen_param[1,posl3])]
		fl3_win=guesses.eigen_param[2:3,posl3]
		Width_l3=tweak_width_profile_l(reform(guesses.eigen_param[1,posl3]), reform(guesses.eigen_param[1,posl0]), 3, numax, gamma0) 
		;Width_l3=widths[3,*]
		Amp_l3=H0*params[parameters_length[0]+2]
	endif
	freq_range=[fmin, fmax]

	noise_param=guesses.noise_param
	noise_s2=guesses.noise_s2
	; Create the .model
	b=byte(exist)
	pos_slash=max(where(b eq 47 OR b eq 92))
	pos_dot=max(where(b eq 46))
	filename=strtrim(b[pos_slash+1:pos_dot-1],2)
	file_out_model=dir_mcmc + filename + '.model'
	file_out_data=dir_spec + filename + '.data'
	;stop

	;stop
	Compile_outputs_POSTFIT_v3, freq_l, els, Width_l0, Amp_l0, Width_l1, Amp_l1, $
		Width_l2, Amp_l2, Width_l3, Amp_l3, Dnu, C_l, freq_range, noise_param, lmax=lmax,$
		file_out_model, fl0_win, fl1_win, fl2_win, fl3_win, KIC_number, noise_s2, $
		global_params_names, global_priors_names, global_priors_params
	
	print, 'Modifications made. The model file is: ' + file_out_model 
	
	; Converting the .sav into .data
	if sav2data eq 1 then begin
		print, 'sav2data=1 ... converting the spectra into ascii'
		print, '           Only f=[fmin,fmax]=[ '+strtrim(fmin,2) +' , ' + strtrim(fmax,2)+' ]'
		print, '           Will be kept'
		print, '           Proceeding...'
		
		openw, 3, file_out_data
		printf, 3, '# File auto-generated by tune_param_mcmc.pro'
		printf, 3, '# freq_range=[ '+strtrim(fmin,2) +' , ' + strtrim(fmax,2)+' ]'
		printf, 3, '! ' + string('frequency', format='(a20)') + $
					      string('power', format='(a20)')
		printf, 3, '* ' + string('(microHz)', format='(a20)') + $
						  string('(ppm^2/microHz)', format='(a20)')
		x=freq[where(freq ge fmin AND freq le fmax)]
		s=spec_reg[where(freq ge fmin AND freq le fmax)]
		for i=long(0), n_elements(x)-1 do begin
			chain=string(x[i], format='(f20.8)') + string(s[i], format='(f20.8)')
			printf,3, chain
		endfor
		close,3	
	endif
	print, '      sav file was converted into a .data file : ' + file_out_data
	
	print, 'all done'
end

function tweak_width_profile_l, nu, nu0, el, numax, Width_at_numax

	; ***** CONSTANTS *****
	G=6.667d-8
	Teff_sun= 5777d ; same values as in the function: seismic_vsini
	Dnu_sun=135.1d
	epsilon_sun=0.5
	;numax_sun=3150d ; THIS IS THE NUMAX IN AMPLITUDE
	numax_sun=2900d ; THIS IS THE NUMAX IN HEIGHT
	R_sun=6.96342d5 ; in km
	M_sun=1.98855d30 ; in kg
	rho_sun=M_sun*1d3/(4d*!pi*(R_sun*1d5)^3d/3d) ; in g.cm-3

	a1_sun=0.4

	; -------- Relation giving the solar width profile from Appourchaux et al. 2014 ------
	alfa=4.97
	Gamma_alfa=4.65
	Wdip=4646. ; depth of the dip
	nu_dip=3083.
	Ddip=4.66

	; Frequencies of the l=0 of the Sun + [1650, 1750, 1850] + [4180, 4280, 4380, 4480] to avoid extrapolation and favor interpolation
	nu_sun=[1957.4748, 2093.5983, 2228.8442, 2362.8797, 2496.3328, 2629.8436, 2764.3597, $
			2899.2249, 3033.9623, 3168.9156, 3303.8225, 3439.3876, 3575.2118, 3711.6045, 3848.5361, 3984.6612]
;	height_sun=[0.55633623, 0.71080326, 0.84916942, 1.0309479, 1.3676815, 2.0930273, 2.8720608, 3.9032770, $
;				3.7507970, 2.8629352, 1.8167902, 0.92533429, 0.42467669, 0.17490098, 0.079882521, 0.038872344]
					
	lnGamma0= alfa*alog(nu_sun/numax_sun) +  alog(Gamma_alfa)
	lnLorentz= -alog( Ddip )/ (1d + (2d *alog(nu_sun/nu_dip)/alog(Wdip/numax_sun))^2)
	Gamma_sun=exp(lnGamma0 + lnLorentz)
	Gamma_sun_at_numax=interpol(Gamma_sun, nu_sun, numax_sun)
	n_at_numax_sun=numax_sun/Dnu_sun - epsilon_sun
	en_list_sun=nu_sun/Dnu_sun - epsilon_sun ; This list will be monotonic from 14 until 29 (with step ~1)
	; ----------------------------------------------------------------------
	
	Nmax=n_elements(nu0)
	
	fit=linfit(findgen(Nmax), nu0)
	Dnu=fit[1]
	n0=floor(fit[0]/Dnu)
	epsilon=fit[0]/Dnu -  n0
	D0=0.02*Dnu

	; defines the radial orders that we keep
	el=0 ; use of l=0 as reference. Can be changed if wished
	n_at_numax=numax/Dnu - epsilon + el/2 + el*(el+1)*D0/Dnu
	en_list=dblarr(Nmax)
	gamma_list=dblarr(Nmax)

	k=0
	for en=-Nmax/2, Nmax/2-1 do begin
		en_list[k]=floor(n_at_numax) + en
	    k=k+1.
	endfor
	
	;w=dblarr(lmax+1, Nmax)

	;for el=0, lmax do begin ;for en=-Nmax/2 + 1 , Nmax/2 do begin
	;	w[el, *]=interpol(Gamma_sun/Gamma_sun_at_numax, en_list_sun - n_at_numax_sun, nu[el, *]/Dnu - n_at_numax) ; recenter and normalize the Width of the Sun
	;	w[el, *]=w[el, *]*Width_at_numax
	;endfor
	w=interpol(Gamma_sun/Gamma_sun_at_numax, en_list_sun - n_at_numax_sun, nu/Dnu - n_at_numax) ; recenter and normalize the Width of the Sun
	w=abs(w*Width_at_numax)

	;stop
	return, w
end


function tweak_width_profile, nu, numax, Width_at_numax

	; ***** CONSTANTS *****
	G=6.667d-8
	Teff_sun= 5777d ; same values as in the function: seismic_vsini
	Dnu_sun=135.1d
	epsilon_sun=0.5
	;numax_sun=3150d ; THIS IS THE NUMAX IN AMPLITUDE
	numax_sun=2900d ; THIS IS THE NUMAX IN HEIGHT
	R_sun=6.96342d5 ; in km
	M_sun=1.98855d30 ; in kg
	rho_sun=M_sun*1d3/(4d*!pi*(R_sun*1d5)^3d/3d) ; in g.cm-3

	a1_sun=0.4

	; -------- Relation giving the solar width profile from Appourchaux et al. 2014 ------
	alfa=4.97
	Gamma_alfa=4.65
	Wdip=4646. ; depth of the dip
	nu_dip=3083.
	Ddip=4.66

	; Frequencies of the l=0 of the Sun + [1650, 1750, 1850] + [4180, 4280, 4380, 4480] to avoid extrapolation and favor interpolation
	nu_sun=[1957.4748, 2093.5983, 2228.8442, 2362.8797, 2496.3328, 2629.8436, 2764.3597, $
			2899.2249, 3033.9623, 3168.9156, 3303.8225, 3439.3876, 3575.2118, 3711.6045, 3848.5361, 3984.6612]
;	height_sun=[0.55633623, 0.71080326, 0.84916942, 1.0309479, 1.3676815, 2.0930273, 2.8720608, 3.9032770, $
;				3.7507970, 2.8629352, 1.8167902, 0.92533429, 0.42467669, 0.17490098, 0.079882521, 0.038872344]
					
	lnGamma0= alfa*alog(nu_sun/numax_sun) +  alog(Gamma_alfa)
	lnLorentz= -alog( Ddip )/ (1d + (2d *alog(nu_sun/nu_dip)/alog(Wdip/numax_sun))^2)
	Gamma_sun=exp(lnGamma0 + lnLorentz)
	Gamma_sun_at_numax=interpol(Gamma_sun, nu_sun, numax_sun)
	n_at_numax_sun=numax_sun/Dnu_sun - epsilon_sun
	en_list_sun=nu_sun/Dnu_sun - epsilon_sun ; This list will be monotonic from 14 until 29 (with step ~1)
	; ----------------------------------------------------------------------
	
	Nmax=n_elements(nu[0,*])
	lmax=n_elements(nu[*,0])-1

	fit=linfit(findgen(Nmax), nu[0,*])
	Dnu=fit[1]
	n0=floor(fit[0]/Dnu)
	epsilon=fit[0]/Dnu -  n0
	if lmax ge 2 then D0=mean(nu[2,*] - nu[0,*])/6. else D0=0.02*Dnu

	; defines the radial orders that we keep
	el=0 ; use of l=0 as reference. Can be changed if wished
	n_at_numax=numax/Dnu - epsilon + el/2 + el*(el+1)*D0/Dnu
	en_list=dblarr(Nmax)
	gamma_list=dblarr(Nmax)

	k=0
	for en=-Nmax/2, Nmax/2-1 do begin
		en_list[k]=floor(n_at_numax) + en
	    k=k+1.
	endfor
	
	w=dblarr(lmax+1, Nmax)

	for el=0, lmax do begin ;for en=-Nmax/2 + 1 , Nmax/2 do begin
		w[el, *]=interpol(Gamma_sun/Gamma_sun_at_numax, en_list_sun - n_at_numax_sun, nu[el, *]/Dnu - n_at_numax) ; recenter and normalize the Width of the Sun
		w[el, *]=abs(w[el, *]*Width_at_numax)
	endfor
	;w=interpol(Gamma_sun/Gamma_sun_at_numax, en_list_sun - n_at_numax_sun, nu/Dnu - n_at_numax) ; recenter and normalize the Width of the Sun
	;w=w*Width_at_numax

	;stop
	return, w
end

; To generate .model files
pro Compile_outputs_POSTFIT_v3, freq_l, els, Width_l0, Amp_l0, Width_l1, Amp_l1, $
	Width_l2, Amp_l2, Width_l3, Amp_l3, Dnu, C_l, freq_range, noise_param, lmax=lmax,$
	file_out_res, fl0_win, fl1_win, fl2_win, fl3_win, KIC_number, noise_s2, $
	global_params_names, global_priors_names, global_priors_params



openw, 3, file_out_res

; ******** properties of the frequencies ********

	lmax=max(els)
	
	param=dblarr(4, n_elements(els))
	param[0,*]= els
	param[1,*]= freq_l
	param[2,*]= 1d ; Errors... don't care about this
	param[3,*]= 1d ; Errors... don't care about this
	param_type=replicate('p', n_elements(els))

	fl0=freq_l[where(els eq 0)]
	if lmax ge 1 then fl1=freq_l[where(els eq 1)]
	if lmax ge 2 then fl2=freq_l[where(els eq 2)]
	if lmax ge 3 then fl3=freq_l[where(els eq 3)]
	
;--------
	if n_elements(lmax) eq 0 then lmax=3

	chain='#KIC ='+KIC_number
	printf, 3, chain
	chain='! '+strtrim(Dnu,1)
	printf, 3, chain
	chain='!! '+strtrim(C_l,1)
	printf, 3, chain

	chain='* '+strtrim(freq_range[0],1) + ' ' + strtrim(freq_range[1],1)
	printf, 3, chain
	chain='# type / l / value / relax_f / relax_H / relax_W '
	printf, 3, chain

for el=0, lmax do begin
	po=where(param[0,*] eq el) ; AND param[1,*] ne 0)

	if po[0] ne -1 then begin
		ftmp=reform(param[1,po])
		typetmp=reform(param_type[po])

		condi=where(ftmp ne 0)

		if condi[0] ne -1 then begin
			ftmp=ftmp[condi]
			typetmp=typetmp[condi]
			
			for i=0, n_elements(ftmp)-1 do begin
					chain=typetmp[i] + '  '+strtrim(el, 1) + '  ' + strtrim(ftmp[i],1) + '  1      1       1'
					printf, 3, chain
			endfor
		endif
	endif
endfor
	chain='# hyper priors'
	printf, 3, chain
	chain='# Extra parameters (obselete)'
	printf, 3, chain
	priors=dblarr(5)
	for i=0, n_elements(priors)-1 do printf, 3, strtrim(priors[i],1)
	
; **************** Parameters for the eigen solutions ************

	; in the order : l / nu / window_min / Window_max / Gamma / H
	printf, 3, '# Eigen solution input parameters: l / nu / window_min / Window_max / Gamma / H'
	for i=0, n_elements(fl0)-1 do printf, 3, format='(i5, 5f12.5)', 0, fl0[i], fl0_win[0,i], fl0_win[1,i], Width_l0[i], Amp_l0[i]
	for i=0, n_elements(fl1)-1 do printf, 3, format='(i5, 5f12.5)', 1, fl1[i], fl1_win[0,i], fl1_win[1,i], Width_l1[i], Amp_l1[i]
	if lmax ge 2 then $
		for i=0, n_elements(fl2)-1 do printf, 3, format='(i5, 5f12.5)', 2, fl2[i], fl2_win[0,i], fl2_win[1,i], Width_l2[i], Amp_l2[i]
	if lmax ge 3 then $
		for i=0, n_elements(fl3)-1 do printf, 3, format='(i5, 5f12.5)', 3, fl3[i], fl3_win[0,i], fl3_win[1,i], Width_l3[i], Amp_l3[i]

	printf, 3, '# Noise parameters: A0/B0/p0, A1/B1/p1, A2/B2/p2, N0'
	printf, 3, noise_param[0:2] ;, format='(+'+strtrim(n_elements(noise_param),1)+'f12.5)',
	printf, 3, noise_param[3:5]
	printf, 3, noise_param[6:8]
	printf, 3, noise_param[9]
	printf, 3, '# Noise Info from output_s2 (use as priors): params / err_m / err_p'
	for i=0, n_elements(noise_s2[0,*])-1 do printf, 3, noise_s2[0,i], noise_s2[1,i], noise_s2[2,i]
	
	; ---- Adding common parameters and fit options ----
	printf, 3, '# Controls and priors for common parameters'
	for i=0, n_elements(global_params_names)-1 do begin
		if global_params_names[i] ne 'model_fullname' then begin
			fmt=['(a25)', '(a20)']
		endif else begin
			fmt=['(a25)', '(a50)']
		endelse
		chain=string(global_params_names[i], format=fmt[0])
		chain=chain + string(global_priors_names[i], format=fmt[1])
		pos_OK=where(global_priors_params[i,*] ne -9999)
		j=0
		if global_priors_params[i,pos_OK[j]] ne -9999 then chain=chain + string(global_priors_params[i,pos_OK[j]], format='(f18.6)')
		for j=1, n_elements(pos_OK)-1 do begin
			chain=chain + string(global_priors_params[i,pos_OK[j]], format='(f18.6)')
		endfor
		printf,3, chain
	endfor

close,3

end


; ------ Gaphical functions ----
; identify which box has been selected... contrary to the old version, can be used in as many boxes as necessary
function conv_coord2id_v3, xid_c, yid_c, min_x_line, max_x_line, min_y_line, max_y_line, n_boxes

tag_id=-1 ; no identification

Width=(max_x_line - min_x_line)/n_boxes
for i=0, n_boxes-1 do begin
	if yid_c ge min_y_line AND yid_c le max_y_line AND xid_c gt min_x_line + i*Width AND xid_c le min_x_line + (i+1)*Width then $
		tag_id=i; l=0
endfor
return, tag_id
end


pro illumina_button, min_x_line, max_x_line, min_y_line, max_y_line, min_txt_x_pos, min_txt_y_pos, txt_bt, color_code, Dnu , $
	col_index, pos,th

Dnu0=Dnu
if Dnu0 eq 0 then Dnu=(max_x_line - min_x_line)*6

	plots, [min_x_line + pos*Dnu/6, min_x_line + pos*Dnu/6], [min_y_line, max_y_line], $
		color=fsc_color(color_code[col_index]), thick=th
	plots, [min_x_line + (pos+1)*Dnu/6, min_x_line + (pos+1)*Dnu/6], [min_y_line, max_y_line], $
		color=fsc_color(color_code[col_index]), thick=th
	plots, [min_x_line + pos*Dnu/6, min_x_line + (pos+1)*Dnu/6], [min_y_line, min_y_line], $
		color=fsc_color(color_code[col_index]), thick=th
	plots, [min_x_line + pos*Dnu/6, min_x_line + (pos+1)*Dnu/6], [max_y_line, max_y_line], $
		color=fsc_color(color_code[col_index]), thick=th

if Dnu0 eq 0 then Dnu=0
	col_list=indgen(n_elements(color_code))
	col_list_bar=col_list[where(col_list ne col_index)]
	for i=0, n_elements(col_list_bar)-1 do xyouts, min_txt_x_pos+ pos*Dnu/6, min_txt_y_pos, txt_bt[pos], $
		color=fsc_color('White'), charthick=2., charsize=2 ; Erase the text

	xyouts, min_txt_x_pos+ pos*Dnu/6, min_txt_y_pos, txt_bt[pos], $
		color=fsc_color(color_code[col_index]), charthick=2., charsize=2
end

function bt_on, x_c, y_c, min_xbox, max_xbox, min_ybox, max_ybox

Out_bt_on=0 ; no identification

	if y_c ge min_ybox AND y_c le max_ybox AND x_c ge min_xbox AND x_c le max_xbox then $
		Out_bt_on=1


return, Out_bt_on
end

pro trace_button_v2, min_x_line, max_x_line, min_y_line, max_y_line, min_txt_x_pos, min_txt_y_pos, txt_bt, color_code, col_index, th;, col_el0=col_el0

		Width=(max_x_line - min_x_line)/n_elements(txt_bt)
		plots, [min_x_line, max_x_line], [min_y_line, min_y_line], color=fsc_color(color_code[col_index]), thick=th
		plots, [min_x_line, max_x_line], [max_y_line, max_y_line], color=fsc_color(color_code[col_index]), thick=th
		for i=0, n_elements(txt_bt)-1 do begin
				plots, [min_x_line + i*Width, min_x_line + i*Width], [min_y_line, max_y_line], color=fsc_color(color_code[col_index]), thick=th
				xyouts, min_txt_x_pos+ i*Width, min_txt_y_pos, txt_bt[i], $
					color=fsc_color(color_code[col_index]), charthick=2., charsize=1.25, $
					alignment=0.9
		endfor
		plots, [max_x_line, max_x_line], [min_y_line, max_y_line], color=fsc_color(color_code[col_index]), thick=th
end
