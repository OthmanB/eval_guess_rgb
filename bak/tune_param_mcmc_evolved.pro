; 1. Read a .MCMC file as generated by mcmc_window_gen (with missing lines at the bottom)
; 2. Show The initial fit as configured in the .MCMC
; 3. Let the user interactively set 
;		- The widths (scaled using the sun width profile)
;		- The Height (scaled using a gaussian)
;		- The splitting a1
;		- The stellar inclination i
; 4. Save the new configuration in .MCMC and .model format for the fit of a1, eta, a3, asym
@build_init_param_a1a2a3_evolved.pro
@global_fit_a1a2a3.pro
;@star_mode_ID.pro
pro tune_param_mcmc_evolved, kic_n, data_type
!p.multi=0

	; ----- ADAPT IN FUNCTION OF YOUR LOCAL DIRECTORY -------
	;dir_mcmc='/home/obenomar/Pro/PSM_WP128_Sept2018/Data/TAMCMC-setups/'
	;dir_spec='/home/obenomar/Pro/PSM_WP128_Sept2018/Data/sav/'
	dir_mcmc='/Volumes/MCMC_RES/Temporary-Outputs/RGB-depressed/Level1/setups/l023-only/'
	dir_spec='/Volumes/MCMC_RES/Temporary-Outputs/RGB-depressed/Level0/tf_mosser2017/'
	
	sav2data=1 ; If set to 1, then convert the sav file into a .data file (keeping f=[fmin,fmax] only)
	; --------------------------------------------------------


	if Data_type eq 'EPIC' then begin
		dir_spec=dir_spec + 'EPIC/'
		dir_mcmc=dir_mcmc + 'EPIC/'
	endif
	if Data_type eq 'KOI_Campante2016' then begin
		dir_spec=dir_spec + 'KOI_Campante2016/'
		dir_mcmc=dir_mcmc + 'KOI_Campante2016/'
	endif

	if Data_type eq 'KOI_Campante2016_wpsd' then begin
		dir_spec=dir_spec + 'KOI_Campante2016_wpsd_Tiago/'
		dir_mcmc=dir_mcmc + 'KOI_Campante2016_wpsd_Tiago/'
	endif

	if Data_type eq 'Difrot' OR Data_type eq 'difrot' then begin
		dir_spec=dir_spec + 'Dif-Rot-2017/'
		dir_mcmc=dir_mcmc + 'Dif-Rot-2017/'
	endif
	if Data_type eq 'Difrot-kasoc' OR Data_type eq 'difrot-kasoc' then begin
		dir_spec=dir_spec + 'Dif-Rot-2017-kasoc/'
		dir_mcmc=dir_mcmc + 'Dif-Rot-2017-kasoc/'
	endif

	; ------ Configuration for the global priors and inputs -----
	; Here are defined the names of the global parameters along with their default priors
	; Completition of the values FOR a1 and inclination IS MADE AT THE END OF THIS FUNCTION
	global_params_names=['freq_smoothness', 'Splitting_a1',  'Asphericity_eta', $
						 'Splitting_a3', 'Asymetry', 'Inclination', $
						 'Visibility_l1', 'Visibility_l2', 'Visibility_l3']
	global_priors_names=['bool', 'Uniform', 'Fix_Auto', $
					     'Fix', 'Fix', 'Uniform_cos', $
					     'Gaussian', 'Gaussian', 'Gaussian']
	global_priors_params=dblarr(n_elements(global_priors_names), 5)
	global_priors_params[*,*]=-9999
	
	global_priors_params[where(global_params_names eq 'freq_smoothness'), 0]=0 ; Activate/Deactivate the smoothness condition on frequencies: NO SMOOTHNESS FOR EVOLVED STARS
	global_priors_params[where(global_params_names eq 'freq_smoothness'), 1]=2.0 ; Smoothness coeficient
	
	; Splitting Fixed to 0. by default
	global_priors_params[where(global_params_names eq 'Splitting_a3'), 0]=0.
	; Asphericity Fixed to the centrifugal effect by default
	global_priors_params[where(global_params_names eq 'Asphericity_eta'), 0]=1
	; Asymetry Fixed to 0 by default
	global_priors_params[where(global_params_names eq 'Asymetry'), 0]=0.
	; Visibilities Gaussian and around Solar values by default
	global_priors_params[where(global_params_names eq 'Visibility_l1'), 0:2]=[1.5, 1.5, 0.15]
	global_priors_params[where(global_params_names eq 'Visibility_l2'), 0:2]=[0.53, 0.53, 0.05]
	global_priors_params[where(global_params_names eq 'Visibility_l3'), 0:2]=[0.08, 0.08, 0.02]
	; -------------------------------------------------------
	
	; Restore the power spectrum
	security=0 & Kic_number=kic_n
	while n_elements(byte(kic_number)) lt 9 AND security lt 10 do begin
		KIC_number='0'+KIC_number
		security=security+1
	endwhile

	exist=file_search(dir_spec+KIC_number+'.sav')
	exist2=file_search(dir_spec+'*' + KIC_n+'*.sav')
	if exist ne '' then restore, dir_spec+KIC_number+'.sav'
	if exist eq '' AND exist2 ne '' then begin
		exist=exist2
		if n_elements(exist2) eq 1 then begin
			restore, exist2[0]
		endif else begin
			print, 'Multiple spectrum files that match the kic_n were found. Please choose one among the list of possible:'
			for i=0, n_elements(exist2)-1 do begin
				print, ' [' + strtrim(i,2) + '] ' + exist2[i]
			endfor
			read, a, format='(i)', prompt='Enter the index of the file: '
			restore, exist2[a]
			exist=exist2[a]
		endelse
	endif
	if exist eq '' AND exist2 eq '' then begin
		print, ' No file found matching any known syntax!'
		stop
	endif
	spec=spec_reg

	; Reading the .MCMC file and format it so that it can be read by global_fit_a1a2a3.pro
	file_out_res=file_search(dir_mcmc + '*' + kic_n +'.MCMC')
	if n_elements(file_out_res) eq 1 then begin
		struc=build_init_param_a1a2a3_evolved(file_out_res)
	endif else begin
		print, 'Multiple mcmc files that match the kic_n were found. Please choose one among the list of possible:'
		for i=0, n_elements(file_out_res)-1 do begin
			print, ' [' + strtrim(i,2) + '] ' + exist2[i]
		endfor
		read, a, format='(i)', prompt='Enter the index of the file: '
		struc=build_init_param_a1a2a3_evolved(file_out_res[a])
	endelse	
	; define initial values for the different variables	
	parameters_length=struc.parameters_length
	params=struc.input
	fmin=struc.fmin
	fmax=struc.fmax
	
	Nmax=parameters_length[0]
	lmax=parameters_length[1]

	; tweaking the smoothing coeficient
	resol=freq[1] - freq[0]
	gamma0=mean(params[total(parameters_length[0:3]): total(parameters_length[0:4])-1])/2.
	scoef=gamma0/resol

	; calculating the initial range of frequencies and the smooth spectra
	xpos=where(freq ge fmin AND freq le fmax)
	x=freq[xpos]
	y_smooth=smooth(spec_reg, scoef, /edge_truncate)
	y_smooth2=smooth(spec_reg, scoef/2, /edge_truncate)
	y_smooth=y_smooth[xpos]
	y_smooth2=y_smooth2[xpos]
	
	; calculating the width profile, scaled with the Sun
	nu=dblarr(lmax+1, Nmax)
	pos0=total(parameters_length[0:1]) + 2 
	for en=0, Nmax-1 do begin	
		for el=0, lmax do begin
			nu[el,en]=params[pos0 + en*(lmax+1) + el]
		endfor
	endfor
	
	; Large separation as defined by the frequency list
	fit=linfit(findgen(Nmax), nu[0,*])
	Dnu=fit[1]

	; defining numax by using the table of frequency and of heights
	numax=total(params[0:Nmax-1]*nu[0,*])/total(params[0:Nmax-1]) ; weighted mean
	; defining Hmax by interpolation of the Heights at numax
	Hmax=interpol(params[0:Nmax-1], nu[0,*], numax)
	Hsigma=3*Dnu
	; Deducing the Heights for l=0 modes
	H0=Hmax * exp(- 0.5*(nu[0,*] - numax)^2./Hsigma^2)
	params[0:Nmax-1]=H0
	
	; calculate the width profile by using the solar profile as reference
	widths=tweak_width_profile(nu, numax, gamma0)
	params[total(parameters_length[0:3]): total(parameters_length[0:4])-1]=widths[0,*]
	
	; Calculating the model using all the calculations from earlier
	model0=global_fit_a1a2a3(params,parameters_length, x)

	ymax=max(y_smooth)
	plot, x, y_smooth, color=fsc_color('Black'), background=fsc_color('white'), $
		xr=[min(x), max(x)], /xst, yr=[0, ymax], /yst
	oplot, x, model0, color=fsc_color('blue')

	; ------- Definition of the increments and of inutial values ---------
	inc=params[total(parameters_length[0:5])]
	inc_old=inc
	a1=0.4 ; Solar value by default params[total(parameters_length[0:2])]
	a1_old=a1
	Hmax_old=Hmax
	Hsigma_old=Hsigma
	gamma0_old=gamma0
	
	dinc=10;
	dwidth=0.1*gamma0
	dHmax=0.1*Hmax
	dHsigma=0.1*Hsigma
	da1=0.1
	; ----------------------------------------------


; ---- Parameters of the graphical interface ----
c_max=2
ps=0
overplot=2 ; show diamonds only
color=['Orange', 'Red','Dark Gray', 'Brown']
win_factor=0.8 ; use this to rescale windows when they are too big/small relative to the used screen resolution

; -----------------------------------------------

; -------------- Compatibility setup --------------
f_list=0 & tag_id_list=0
for el=0, lmax do begin
	test=where(nu[el,*] ne 0)
	if test[0] ne -1 then begin
		tag_id_list=[ tag_id_list, dblarr(n_elements(test))+el ]
	 	f_list=[f_list, reform(nu[el,test])]
	endif
endfor
; -------------------------------------------------

;stop
coef=1.
key='n' & status=0
while key ne 'y' do begin
	;status=0 ; reinitialise the status at the begining of the loop

	!p.multi=[0,1,2]
	window,3,xsize=win_factor*1580,ysize=win_factor*750,ypos=10, title='MODE TAGGING', retain=2
		mainscreen_goto:
	
		Nbegin=fmin/Dnu
		Nend=fmax/Dnu
		mini=abs(Dnu*(Nbegin)) & maxi=abs(Dnu*(Nend))
		cp=where(freq ge mini AND freq le maxi)
		if cp[0] eq -1 then begin
			mini=min(freq) & maxi=max(freq)
		endif
		
		borne_y_max=max(smooth(spec[where(freq ge mini AND freq le maxi)],2, /edge_truncate))*coef
		plot, freq,/Nodata,xr=[mini,maxi],yr=[0,borne_y_max*1.1],/xst,/yst,$
			background=fsc_color('White'),color=FSC_Color('Black'),thick=1,$
			xtitle='Frequency (microHz)',ytitle='Power (ppm^2/microHz)', title='Dnu='+strtrim(Dnu, 1)
		oplot, x, y_smooth2,color=FSC_Color('Gray'),thick=1
		;oplot, x, y_smooth,color=FSC_Color('Black'),thick=2
		oplot, x, model0, color=fsc_color('blue'), thick=2
		for i=0, nend-nbegin+1 do begin
			plots, [(nbegin-1+i)*Dnu,(nbegin-1+i)*Dnu], [0, borne_y_max], color=fsc_color('Brown'), linestyle=1
			xyouts, (nbegin-1+i)*Dnu + Dnu/2 , borne_y_max*0.98, strtrim(i,1), color=fsc_color('Black'), charsize=1.5
		endfor
		;stop
		f_l_status=where(f_list ne 0)
		posf_l0=where(f_list ne 0 AND tag_id_list eq 0 )
		posf_l1=where(f_list ne 0 AND tag_id_list eq 1 )
		posf_l2=where(f_list ne 0 AND tag_id_list eq 2 )
		posf_l3=where(f_list ne 0 AND tag_id_list eq 3 )
		if posf_l0[0] ne -1 then plots, f_list[posf_l0], 0.7*borne_y_max, color=fsc_color('Orange'), symsize=0.75, psym=4 ; tag modes
		if posf_l0[0] ne -1 then plots, f_list[posf_l0], 0.7*borne_y_max, color=fsc_color('Orange'), symsize=1, psym=4 ; tag modes
		if posf_l1[0] ne -1 then plots, f_list[posf_l1], 0.6*borne_y_max, color=fsc_color('Blue'), symsize=0.75, psym=4 ; tag modes
		if posf_l1[0] ne -1 then plots, f_list[posf_l1], 0.6*borne_y_max, color=fsc_color('Blue'), symsize=1, psym=4 ; tag modes
		if posf_l2[0] ne -1 then plots, f_list[posf_l2], 0.5*borne_y_max, color=fsc_color('Dark Gray'), symsize=0.5, psym=4 ; tag modes
		if posf_l2[0] ne -1 then plots, f_list[posf_l2], 0.5*borne_y_max, color=fsc_color('Dark Gray'), symsize=0.75, psym=4 ; tag modes
		if posf_l3[0] ne -1 then plots, f_list[posf_l3], 0.4*borne_y_max, color=fsc_color('Brown'), symsize=0.5, psym=4 ; tag modes
		if posf_l3[0] ne -1 then plots, f_list[posf_l3], 0.4*borne_y_max, color=fsc_color('Brown'), symsize=0.75, psym=4 ; tag modes

			min_xbox=maxi - 0.09*(maxi - mini) & max_xbox=maxi & min_ybox=0.75*borne_y_max & max_ybox=0.9*borne_y_max
			min_xtxt=maxi - 0.088*(maxi - mini) & min_ytxt=0.8*borne_y_max
			col_l=['Gray','Red','Orange','Green']
			txt_bt='VALIDATION'
			if f_l_status[0] eq -1 then begin
				col_i=0
				illumina_button, min_xbox, max_xbox, min_ybox, max_ybox, min_xtxt, min_ytxt, txt_bt, col_l, 0 , col_i, 0d,2
			endif
			if f_l_status[0] ne -1 then begin
				col_i=1
				illumina_button, min_xbox, max_xbox, min_ybox, max_ybox, min_xtxt, min_ytxt, txt_bt, col_l, 0 , col_i, 0d,2
			endif
		
		if status ne 2 then begin
			print, 'Choose a cadran (by click) Or validate the parameters '
			if status eq 0 then begin
				cursor, ff,gg, /data ; else it means we arrived by the goto
				wait, 0.1
			endif
			End_bt=bt_on(ff, gg, min_xbox, max_xbox, min_ybox, max_ybox) ; tells if we clicked in that zone
			if f_l_status[0] ne -1 AND End_bt eq 1 then begin
				col_i=2
				illumina_button, min_xbox, max_xbox, min_ybox, max_ybox, min_xtxt, min_ytxt, txt_bt, col_l, 0 , col_i, 0d,2
				print, 'Waiting for confirmation of the Validation'
				;wait,0.4
				;cursor, ff,gg, /data
				wait, 0.1
				End_bt2=bt_on(ff, gg, min_xbox, max_xbox, min_ybox, max_ybox) ; tells if we clicked in that zone
				if End_bt2 eq 1 then begin
					col_i=3
					illumina_button, min_xbox, max_xbox, min_ybox, max_ybox, min_xtxt, min_ytxt, txt_bt, col_l, 0 , col_i, 0d,2
					print, 'Fine tuning ended !'
					status=6 ; status for getting out of the loop!
					goto, end_goto
					wait, 0.2
				endif else begin
					col_i=1
					illumina_button, min_xbox, max_xbox, min_ybox, max_ybox, min_xtxt, min_ytxt, txt_bt, col_l, 0 , col_i, 0d,2
					End_bt=0 ; cancel the first click
					status=5
				endelse
			endif
		endif
			x_l=(nbegin-1 + findgen(nend - nbegin +2))*Dnu
			pos=max(where(ff ge x_l))
	
			if End_bt eq 0 then begin
				xyouts, (nbegin-1+ pos)*Dnu + Dnu/2 , borne_y_max*0.98, strtrim(pos,1), color=fsc_color('Green'), charsize=1.5, charthick=2
				plots, [(nbegin-1+pos)*Dnu,(nbegin-1+pos)*Dnu], [0, borne_y_max], color=fsc_color('Green'), linestyle=2, thick=2
				plots, [(nbegin-1+pos+1)*Dnu,(nbegin-1+pos+1)*Dnu], [0, borne_y_max], color=fsc_color('Green'), linestyle=2, thick=2
	
				if n_elements(x_l) ne pos+1 then maxi=x_l[pos+1] ; else maxi remains maxi
				mini=x_l[pos] & borne_y_max=max(smooth(spec[where(freq ge mini AND freq le maxi)],2))*1.1*coef
			endif

			plot, freq,/Nodata,xr=[mini,maxi],yr=[0,borne_y_max*1.1],/xst,/yst,$
				background=fsc_color('White'),color=FSC_Color('Black'),thick=1,$
				xtitle='frequency (microHz)',ytitle='power (ppm^2/microHz)', title='Dnu='+strtrim(Dnu, 1)
			oplot, freq,spec,color=FSC_Color('Gray'),thick=1
			oplot, x,y_smooth2,color=FSC_Color('Dark Gray'),thick=2
			;oplot, x, y_smooth,color=FSC_Color('Black'),thick=2
			oplot, x, model0, color=fsc_color('blue'), thick=2
			xyouts, (nbegin-1+ pos)*Dnu + Dnu/50 , borne_y_max*0.98, strtrim(pos,1), color=fsc_color('Green'), charsize=2

			;level=0.999
			;threshold=proba_chi22p(1d, smooth_coef, level)
			;oplot, freq,  dblarr(n_elements(freq)) + threshold, color=fsc_color('Red'), linestyle=2, thick=2

			if posf_l0[0] ne -1 then plots, f_list[posf_l0], 0.7*borne_y_max, color=fsc_color('Orange'), symsize=1.5, psym=4 ; tag modes
			if posf_l0[0] ne -1 then plots, f_list[posf_l0], 0.7*borne_y_max, color=fsc_color('Orange'), symsize=1, psym=4 ; tag modes
			if posf_l1[0] ne -1 then plots, f_list[posf_l1], 0.6*borne_y_max, color=fsc_color('Blue'), symsize=1.5, psym=4 ; tag modes
			if posf_l1[0] ne -1 then plots, f_list[posf_l1], 0.6*borne_y_max, color=fsc_color('Blue'), symsize=1, psym=4 ; tag modes
			if posf_l2[0] ne -1 then plots, f_list[posf_l2], 0.5*borne_y_max, color=fsc_color('Dark Gray'), symsize=1.5, psym=4 ; tag modes
			if posf_l2[0] ne -1 then plots, f_list[posf_l2], 0.5*borne_y_max, color=fsc_color('Dark Gray'), symsize=1, psym=4 ; tag modes
			if posf_l3[0] ne -1 then plots, f_list[posf_l3], 0.4*borne_y_max, color=fsc_color('Brown'), symsize=1.5, psym=4 ; tag modes
			if posf_l3[0] ne -1 then plots, f_list[posf_l3], 0.4*borne_y_max, color=fsc_color('Brown'), symsize=1, psym=4 ; tag modes
		; ******* Button *******
		; ---- Config ----
		min_y_line=0.85*borne_y_max & min_x_line= (nbegin-1 + pos)*Dnu + Dnu/6
		max_y_line=borne_y_max*1.1 & max_x_line= (nbegin-1+ pos+1)*Dnu
		min_txt_y_pos=(max_y_line + min_y_line)/2  & min_txt_x_pos= min_x_line + Dnu/12 - Dnu/12*0.3
		txt_bt=['PASS','inc -', 'inc+', 'a1 -' , 'a1+', 'Hmax-', 'Hmax+', 'Hsig-', 'Hsig+', 'width-', 'width +']
		color_code=['Gray', 'Red', 'Orange', 'Green']
		; Gray; deactivated / Red: Waiting for confirmation / Orange: Need final confirmation / Green: Validated
		plots, [min_x_line, max_x_line], [min_y_line, min_y_line], color=fsc_color(color_code[0]), thick=2.
		col_ind=1
		trace_button_v2, min_x_line, max_x_line, min_y_line, max_y_line, min_txt_x_pos, min_txt_y_pos, txt_bt, color_code , col_ind, 2

		redo_goto:
		status=1
		if status eq 1 or status eq 2 then begin
			f_list0=f_list & tag_id_list0=tag_id_list
			print, 'Choose an action'
			xyouts, min_x_line - Dnu/9 + Dnu/50, min_txt_y_pos*1.05, 'Hmax='+string(Hmax_old,format='(f6.3)'), color=fsc_color('White'), charthick=2, charsize=1.25 ; Erase
			xyouts, min_x_line - Dnu/9 + Dnu/50, min_txt_y_pos*1.05, 'Hmax='+string(Hmax,format='(f6.3)'), color=fsc_color('Orange'), charthick=2, charsize=1.25 ; Write
			xyouts, min_x_line - Dnu/9 + Dnu/50, min_txt_y_pos*0.99, 'Hsig='+string(Hsigma_old,format='(f6.1)'), color=fsc_color('White'), charthick=2, charsize=1.25 ; Erase
			xyouts, min_x_line - Dnu/9 + Dnu/50, min_txt_y_pos*0.99, 'Hsig='+string(Hsigma,format='(f6.1)'), color=fsc_color('Orange'), charthick=2, charsize=1.25 ; Write
			xyouts, min_x_line - Dnu/9 + Dnu/50, min_txt_y_pos*0.93, 'width='+string(gamma0_old,format='(f5.1)'), color=fsc_color('White'), charthick=2, charsize=1.25 ; Erase
			xyouts, min_x_line - Dnu/9 + Dnu/50, min_txt_y_pos*0.93, 'width='+string(gamma0,format='(f5.1)'), color=fsc_color('Orange'), charthick=2, charsize=1.25 ; Write
			xyouts, min_x_line - Dnu/9 + Dnu/50, min_txt_y_pos*0.87, 'inc='+string(inc_old,format='(f4.1)'), color=fsc_color('White'), charthick=2, charsize=1.25 ; Erase
			xyouts, min_x_line - Dnu/9 + Dnu/50, min_txt_y_pos*0.87, 'inc='+string(inc,format='(f4.1)'), color=fsc_color('Orange'), charthick=2, charsize=1.25 ; Write
			xyouts, min_x_line - Dnu/9 + Dnu/50, min_txt_y_pos*0.81, 'nus='+string(a1_old,format='(f5.2)'), color=fsc_color('White'), charthick=2, charsize=1.25 ; Erase
			xyouts, min_x_line - Dnu/9 + Dnu/50, min_txt_y_pos*0.81, 'nus='+string(a1,format='(f5.2)'), color=fsc_color('Orange'), charthick=2, charsize=1.25; Write

			cursor, xid_c, yid_c, /data
			wait,0.2
			n_boxes=n_elements(txt_bt)
			tag_id=conv_coord2id_v3(xid_c, yid_c, min_x_line, max_x_line, min_y_line, max_y_line, n_boxes)
			;print, tag_id
			;stop
			if tag_id eq -1 then status=4 ; cancellation status, means we stay on the current screen but cancel all actions
			; ------------ Perform action ---------
			if tag_id ne -1 then begin
				if tag_id eq 0 then begin
					status=0
					goto, mainscreen_goto
				endif
				if tag_id eq 1 then begin
					inc_old=inc
					inc=params[total(parameters_length[0:5])] - dinc
					if inc le 0 then inc=0
					params[total(parameters_length[0:5])]= inc		
				endif
				if tag_id eq 2 then begin
					inc_old=inc
					inc=params[total(parameters_length[0:5])] + dinc
					if inc ge 90 then inc=90
					params[total(parameters_length[0:5])]= inc		
				endif
				if tag_id eq 3 then begin
					a1_old=params[total(parameters_length[0:2])]
					a1= params[total(parameters_length[0:2])] - da1
					if a1 lt 0. then a1=0.01
					if a1 ge 5 then a1=5
					params[total(parameters_length[0:2])]=a1
				endif
				if tag_id eq 4 then begin
					a1_old=params[total(parameters_length[0:2])]
					a1= params[total(parameters_length[0:2])] + da1
					if a1 lt 0 then a1=0.01
					if a1 ge 5 then a1=5
					params[total(parameters_length[0:2])]=a1
				endif
				if tag_id eq 5 then begin
					Hmax_old=Hmax
					Hmax=Hmax - dHmax
					if Hmax le 0 then Hmax=dHmax
					H0=Hmax * exp(- 0.5*(nu[0,*] - numax)^2./Hsigma^2)
					params[0:Nmax-1]= H0
				endif
				if tag_id eq 6 then begin
					Hmax_old=Hmax
					Hmax=Hmax + dHmax
					if Hmax le 0 then Hmax=dHmax
					H0=Hmax * exp(- 0.5*(nu[0,*] - numax)^2./Hsigma^2)
					params[0:Nmax-1]= H0				
				endif
				if tag_id eq 7 then begin
					Hsigma_old=Hsigma
					Hsigma=Hsigma - dHsigma
					if Hsigma le 0 then Hsigma=dHsigma
					H0=Hmax * exp(- 0.5*(nu[0,*] - numax)^2./Hsigma^2)
					params[0:Nmax-1]= H0
				endif
				if tag_id eq 8 then begin
					Hsigma=Hsigma + dHsigma
					if Hsigma le 0 then Hsigma=dHsigma
					H0=Hmax * exp(- 0.5*(nu[0,*] - numax)^2./Hsigma^2)
					params[0:Nmax-1]= H0
				endif
				if tag_id eq 9 then begin
					gamma0_old=gamma0
					gamma0=gamma0 - dwidth
					if gamma0 le 0. then gamma0=dwidth
					widths=tweak_width_profile(nu, numax, gamma0)
					pos=where(widths[0,*] le 0)
					if pos[0] ne -1 then widths[0,pos]=min(abs(widths))
					params[total(parameters_length[0:3]): total(parameters_length[0:4])-1]=widths[0,*]
				endif
				if tag_id eq 10 then begin
					gamma0_old=gamma0
					gamma0=gamma0 + dwidth
					if gamma0 le 0. then gamma0=dwidth
					widths=tweak_width_profile(nu, numax, gamma0)
					pos=where(widths[0,*] le 0)
					if pos[0] ne -1 then widths[0,pos]=min(abs(widths))
					params[total(parameters_length[0:3]): total(parameters_length[0:4])-1]=widths[0,*]				
				endif
				
				; Update the model
				model0=global_fit_a1a2a3(params,parameters_length, x)

				;col_index=2
				;pos=tag_id+1
				;th=3
				;illumina_button, min_x_line, max_x_line, min_y_line, max_y_line, min_txt_x_pos, min_txt_y_pos, $
				;	txt_bt, color_code, Dnu , col_index, pos, th
				status=2 ; chosen status
			endif
		endif
		end_goto:
		if status eq 6 then key='y' ; Status associated to the end of the peak bagging

endwhile
	
	; -------------
	; Update the global priors with tweaked values
	; -------------
	; Splitting a1:
	if a1 le 0.5 then a1max=1.5
	if a1 gt 0.5 and a1 le 1.0 then a1max=2.5
	if a1 gt 1.0 then a1max=5.
	global_priors_params[where(global_params_names eq 'Splitting_a1'), 0:2]=[a1, 0, a1max]
	
	; Inclination:
	global_priors_params[where(global_params_names eq 'Inclination'), 0:2]=[inc, 0., 1]

	; --- Formating output so that they can be written in a model file -----
	guesses=Read_MCMC_input(file_out_res, Dnu=Dnu, C_l=C_l, mode_range=mode_range)
	posl0=where(guesses.eigen_param[0,*] eq 0)
	posl1=where(guesses.eigen_param[0,*] eq 1)
	posl2=where(guesses.eigen_param[0,*] eq 2)
	posl3=where(guesses.eigen_param[0,*] eq 3)
	
	els=dblarr(n_elements(posl0))
	freq_l=reform(guesses.eigen_param[1,posl0])
	fl0_win=guesses.eigen_param[2:3,posl0]
	Width_l0=widths[0,*]
	Amp_l0=H0
	if lmax ge 1 then begin
		if posl1[0] ne -1 then begin
			els=[els, dblarr(n_elements(posl1)) + 1]
			freq_l=[freq_l, reform(guesses.eigen_param[1,posl1])]
			fl1_win=guesses.eigen_param[2:3,posl1]	 
			Width_l1=widths[1,*]
			Amp_l1=H0*params[parameters_length[0]]
		endif
	endif
	if lmax ge 2 then begin
		if posl2[0] ne -1 then begin
			els=[els, dblarr(n_elements(posl2)) + 2]
			freq_l=[freq_l, reform(guesses.eigen_param[1,posl2])]
			fl2_win=guesses.eigen_param[2:3,posl2]
			Width_l2=widths[2,*]	
			Amp_l2=H0*params[parameters_length[0]+1]
		endif
	endif
	if lmax ge 3 then begin
		if posl3[0] ne -1 then begin
			els=[els, dblarr(n_elements(posl3)) + 3]
			freq_l=[freq_l, reform(guesses.eigen_param[1,posl3])]
			fl3_win=guesses.eigen_param[2:3,posl3]
			Width_l3=widths[3,*]
			Amp_l3=H0*params[parameters_length[0]+2]
		endif
	endif
	freq_range=[fmin, fmax]

	noise_param=guesses.noise_param
	noise_s2=guesses.noise_s2
	; Create the .model
	b=byte(exist)
	pos_slash=max(where(b eq 47 OR b eq 92))
	pos_dot=max(where(b eq 46))
	filename=strtrim(b[pos_slash+1:pos_dot-1],2)
	file_out_model=dir_mcmc + filename + '.model'
	file_out_data=dir_spec + filename + '.data'
	;stop

	Compile_outputs_POSTFIT_v3, freq_l, els, Width_l0, Amp_l0, Width_l1, Amp_l1, $
		Width_l2, Amp_l2, Width_l3, Amp_l3, Dnu, C_l, freq_range, noise_param, lmax=lmax,$
		file_out_model, fl0_win, fl1_win, fl2_win, fl3_win, KIC_number, noise_s2, $
		global_params_names, global_priors_names, global_priors_params
	
	print, 'Modifications made. The model file is: ' + file_out_model 
	
	; Converting the .sav into .data
	if sav2data eq 1 then begin
		print, 'sav2data=1 ... converting the spectra into ascii'
		print, '           Only f=[fmin,fmax]=[ '+strtrim(fmin,2) +' , ' + strtrim(fmax,2)+' ]'
		print, '           Will be kept'
		print, '           Proceeding...'
		
		openw, 3, file_out_data
		printf, 3, '# File auto-generated by tune_param_mcmc.pro'
		printf, 3, '# freq_range=[ '+strtrim(fmin,2) +' , ' + strtrim(fmax,2)+' ]'
		printf, 3, '! ' + string('frequency', format='(a20)') + $
					      string('power', format='(a20)')
		printf, 3, '* ' + string('(microHz)', format='(a20)') + $
						  string('(ppm^2/microHz)', format='(a20)')
		x=freq[where(freq ge fmin AND freq le fmax)]
		s=spec_reg[where(freq ge fmin AND freq le fmax)]
		for i=long(0), n_elements(x)-1 do begin
			chain=string(x[i], format='(f20.8)') + string(s[i], format='(f20.8)')
			printf,3, chain
		endfor
		close,3	
	endif
	print, '      sav file was converted into a .data file : ' + file_out_data
	
	print, 'all done'
end

function tweak_width_profile, nu, numax, Width_at_numax

	; ***** CONSTANTS *****
	G=6.667d-8
	Teff_sun= 5777d ; same values as in the function: seismic_vsini
	Dnu_sun=135.1d
	epsilon_sun=0.5
	;numax_sun=3150d ; THIS IS THE NUMAX IN AMPLITUDE
	numax_sun=2900d ; THIS IS THE NUMAX IN HEIGHT
	R_sun=6.96342d5 ; in km
	M_sun=1.98855d30 ; in kg
	rho_sun=M_sun*1d3/(4d*!pi*(R_sun*1d5)^3d/3d) ; in g.cm-3

	a1_sun=0.4

	; -------- Relation giving the solar width profile from Appourchaux et al. 2014 ------
	alfa=4.97
	Gamma_alfa=4.65
	Wdip=4646. ; depth of the dip
	nu_dip=3083.
	Ddip=4.66

	; Frequencies of the l=0 of the Sun + [1650, 1750, 1850] + [4180, 4280, 4380, 4480] to avoid extrapolation and favor interpolation
	nu_sun=[1957.4748, 2093.5983, 2228.8442, 2362.8797, 2496.3328, 2629.8436, 2764.3597, $
			2899.2249, 3033.9623, 3168.9156, 3303.8225, 3439.3876, 3575.2118, 3711.6045, 3848.5361, 3984.6612]
;	height_sun=[0.55633623, 0.71080326, 0.84916942, 1.0309479, 1.3676815, 2.0930273, 2.8720608, 3.9032770, $
;				3.7507970, 2.8629352, 1.8167902, 0.92533429, 0.42467669, 0.17490098, 0.079882521, 0.038872344]
					
	lnGamma0= alfa*alog(nu_sun/numax_sun) +  alog(Gamma_alfa)
	lnLorentz= -alog( Ddip )/ (1d + (2d *alog(nu_sun/nu_dip)/alog(Wdip/numax_sun))^2)
	Gamma_sun=exp(lnGamma0 + lnLorentz)
	Gamma_sun_at_numax=interpol(Gamma_sun, nu_sun, numax_sun)
	n_at_numax_sun=numax_sun/Dnu_sun - epsilon_sun
	en_list_sun=nu_sun/Dnu_sun - epsilon_sun ; This list will be monotonic from 14 until 29 (with step ~1)
	; ----------------------------------------------------------------------
	
	Nmax=n_elements(nu[0,*])
	lmax=n_elements(nu[*,0])-1

	fit=linfit(findgen(Nmax), nu[0,*])
	Dnu=fit[1]
	n0=floor(fit[0]/Dnu)
	epsilon=fit[0]/Dnu -  n0
	if lmax ge 2 then D0=mean(nu[2,*] - nu[0,*])/6. else D0=0.02*Dnu

	; defines the radial orders that we keep
	el=0 ; use of l=0 as reference. Can be changed if wished
	n_at_numax=numax/Dnu - epsilon + el/2 + el*(el+1)*D0/Dnu
	en_list=dblarr(Nmax)
	gamma_list=dblarr(Nmax)

	k=0
	for en=-Nmax/2, Nmax/2-1 do begin
		en_list[k]=floor(n_at_numax) + en
	    k=k+1.
	endfor
	
	w=dblarr(lmax+1, Nmax)

	for el=0, lmax do begin ;for en=-Nmax/2 + 1 , Nmax/2 do begin
		w[el, *]=interpol(Gamma_sun/Gamma_sun_at_numax, en_list_sun - n_at_numax_sun, nu[el, *]/Dnu - n_at_numax) ; recenter and normalize the Width of the Sun
		w[el, *]=w[el, *]*Width_at_numax
	endfor

	;stop
	return, w
end

; To generate .model files
pro Compile_outputs_POSTFIT_v3, freq_l, els, Width_l0, Amp_l0, Width_l1, Amp_l1, $
	Width_l2, Amp_l2, Width_l3, Amp_l3, Dnu, C_l, freq_range, noise_param, lmax=lmax,$
	file_out_res, fl0_win, fl1_win, fl2_win, fl3_win, KIC_number, noise_s2, $
	global_params_names, global_priors_names, global_priors_params



openw, 3, file_out_res

; ******** properties of the frequencies ********

	lmax=max(els)
	
	param=dblarr(4, n_elements(els))
	param[0,*]= els
	param[1,*]= freq_l
	param[2,*]= 1d ; Errors... don't care about this
	param[3,*]= 1d ; Errors... don't care about this
	param_type=replicate('p', n_elements(els))

	fl0=freq_l[where(els eq 0)]
	if lmax ge 1 then fl1=freq_l[where(els eq 1)]
	if lmax ge 2 then fl2=freq_l[where(els eq 2)]
	if lmax ge 3 then fl3=freq_l[where(els eq 3)]
	
;--------
	if n_elements(lmax) eq 0 then lmax=3

	chain='#KIC ='+KIC_number
	printf, 3, chain
	chain='! '+strtrim(Dnu,1)
	printf, 3, chain
	chain='!! '+strtrim(C_l,1)
	printf, 3, chain

	chain='* '+strtrim(freq_range[0],1) + ' ' + strtrim(freq_range[1],1)
	printf, 3, chain
	chain='# type / l / value / relax_f / relax_H / relax_W '
	printf, 3, chain

for el=0, lmax do begin
	po=where(param[0,*] eq el) ; AND param[1,*] ne 0)

	if po[0] ne -1 then begin
		ftmp=reform(param[1,po])
		typetmp=reform(param_type[po])

		condi=where(ftmp ne 0)

		if condi[0] ne -1 then begin
			ftmp=ftmp[condi]
			typetmp=typetmp[condi]
			
			for i=0, n_elements(ftmp)-1 do begin
					chain=typetmp[i] + '  '+strtrim(el, 1) + '  ' + strtrim(ftmp[i],1) + '  1      1       1'
					printf, 3, chain
			endfor
		endif
	endif
endfor
	chain='# hyper priors'
	printf, 3, chain
	chain='# Extra parameters (obselete)'
	printf, 3, chain
	priors=dblarr(5)
	for i=0, n_elements(priors)-1 do printf, 3, strtrim(priors[i],1)
	
; **************** Parameters for the eigen solutions ************

	; in the order : l / nu / window_min / Window_max / Gamma / H
	printf, 3, '# Eigen solution input parameters: l / nu / window_min / Window_max / Gamma / H'
	for i=0, n_elements(fl0)-1 do printf, 3, format='(i5, 5f12.5)', 0, fl0[i], fl0_win[0,i], fl0_win[1,i], Width_l0[i], Amp_l0[i]
	for i=0, n_elements(fl1)-1 do printf, 3, format='(i5, 5f12.5)', 1, fl1[i], fl1_win[0,i], fl1_win[1,i], Width_l1[i], Amp_l1[i]
	if lmax ge 2 then $
		for i=0, n_elements(fl2)-1 do printf, 3, format='(i5, 5f12.5)', 2, fl2[i], fl2_win[0,i], fl2_win[1,i], Width_l2[i], Amp_l2[i]
	if lmax ge 3 then $
		for i=0, n_elements(fl3)-1 do printf, 3, format='(i5, 5f12.5)', 3, fl3[i], fl3_win[0,i], fl3_win[1,i], Width_l3[i], Amp_l3[i]

	printf, 3, '# Noise parameters: A0/B0/p0, A1/B1/p1, A2/B2/p2, N0'
	printf, 3, noise_param[0:2] ;, format='(+'+strtrim(n_elements(noise_param),1)+'f12.5)',
	printf, 3, noise_param[3:5]
	printf, 3, noise_param[6:8]
	printf, 3, noise_param[9]
	printf, 3, '# Noise Info from output_s2 (use as priors): params / err_m / err_p'
	for i=0, n_elements(noise_s2[0,*])-1 do printf, 3, noise_s2[0,i], noise_s2[1,i], noise_s2[2,i]
	
	; ---- Adding common parameters and fit options ----
	printf, 3, '# Controls and priors for common parameters'
	for i=0, n_elements(global_params_names)-1 do begin
		chain=string(global_params_names[i], format='(a25)')
		chain=chain + string(global_priors_names[i], format='(a20)')
		pos_OK=where(global_priors_params[i,*] ne -9999)
		for j=0, n_elements(pos_OK)-1 do begin
			chain=chain + string(global_priors_params[i,pos_OK[j]], format='(f18.6)')
		endfor
		printf,3, chain
	endfor

close,3

end


; ------ Gaphical functions ----
; identify which box has been selected... contrary to the old version, can be used in as many boxes as necessary
function conv_coord2id_v3, xid_c, yid_c, min_x_line, max_x_line, min_y_line, max_y_line, n_boxes

tag_id=-1 ; no identification

Width=(max_x_line - min_x_line)/n_boxes
for i=0, n_boxes-1 do begin
	if yid_c ge min_y_line AND yid_c le max_y_line AND xid_c gt min_x_line + i*Width AND xid_c le min_x_line + (i+1)*Width then $
		tag_id=i; l=0
endfor
return, tag_id
end


pro illumina_button, min_x_line, max_x_line, min_y_line, max_y_line, min_txt_x_pos, min_txt_y_pos, txt_bt, color_code, Dnu , $
	col_index, pos,th

Dnu0=Dnu
if Dnu0 eq 0 then Dnu=(max_x_line - min_x_line)*6

	plots, [min_x_line + pos*Dnu/6, min_x_line + pos*Dnu/6], [min_y_line, max_y_line], $
		color=fsc_color(color_code[col_index]), thick=th
	plots, [min_x_line + (pos+1)*Dnu/6, min_x_line + (pos+1)*Dnu/6], [min_y_line, max_y_line], $
		color=fsc_color(color_code[col_index]), thick=th
	plots, [min_x_line + pos*Dnu/6, min_x_line + (pos+1)*Dnu/6], [min_y_line, min_y_line], $
		color=fsc_color(color_code[col_index]), thick=th
	plots, [min_x_line + pos*Dnu/6, min_x_line + (pos+1)*Dnu/6], [max_y_line, max_y_line], $
		color=fsc_color(color_code[col_index]), thick=th

if Dnu0 eq 0 then Dnu=0
	col_list=indgen(n_elements(color_code))
	col_list_bar=col_list[where(col_list ne col_index)]
	for i=0, n_elements(col_list_bar)-1 do xyouts, min_txt_x_pos+ pos*Dnu/6, min_txt_y_pos, txt_bt[pos], $
		color=fsc_color('White'), charthick=2., charsize=2 ; Erase the text

	xyouts, min_txt_x_pos+ pos*Dnu/6, min_txt_y_pos, txt_bt[pos], $
		color=fsc_color(color_code[col_index]), charthick=2., charsize=2
end

function bt_on, x_c, y_c, min_xbox, max_xbox, min_ybox, max_ybox

Out_bt_on=0 ; no identification

	if y_c ge min_ybox AND y_c le max_ybox AND x_c ge min_xbox AND x_c le max_xbox then $
		Out_bt_on=1


return, Out_bt_on
end

pro trace_button_v2, min_x_line, max_x_line, min_y_line, max_y_line, min_txt_x_pos, min_txt_y_pos, txt_bt, color_code, col_index, th;, col_el0=col_el0

		Width=(max_x_line - min_x_line)/n_elements(txt_bt)
		plots, [min_x_line, max_x_line], [min_y_line, min_y_line], color=fsc_color(color_code[col_index]), thick=th
		plots, [min_x_line, max_x_line], [max_y_line, max_y_line], color=fsc_color(color_code[col_index]), thick=th
		for i=0, n_elements(txt_bt)-1 do begin
				plots, [min_x_line + i*Width, min_x_line + i*Width], [min_y_line, max_y_line], color=fsc_color(color_code[col_index]), thick=th
				xyouts, min_txt_x_pos+ i*Width, min_txt_y_pos, txt_bt[i], $
					color=fsc_color(color_code[col_index]), charthick=2., charsize=1.25, $
					alignment=0.9
		endfor
		plots, [max_x_line, max_x_line], [min_y_line, max_y_line], color=fsc_color(color_code[col_index]), thick=th
end
